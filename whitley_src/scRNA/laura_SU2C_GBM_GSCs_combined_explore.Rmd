---
title: "R Notebook"
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 6
params:
  inp_data: '/home/owenwhitley/projects/su2c_v2/data/preprocessed/scRNA/GSCs_Tumour_combined/BTSC_Tumour_combined_obj_seurat_subset.rds'
  results_dir: '/home/owenwhitley/projects/su2c_v2/results/scRNA/GSCs_Tumour_combined/'
  results_file: 'BTSC_Tumour_combined_id_mixed_subsets.rds'
  feats_plot: 'NULL'
  reductions_plot: 'pca'
  dims_use_mapping: 'NULL'
---

# Setup

## Load Data + functions, setup params

```{r}

library(Matrix)
library(Seurat)
library(ggplot2)
library(SummarizedExperiment)
library(R.devices)

source('./laura_SU2C_GBM_GSCs_combined_explore_helpers.R')

# preproc_dir <- '~/projects/su2c_v2/data/preprocessed/scRNA/GSCs_Tumour_combined'
# data_fname <- 'BTSC_Tumour_combined_obj.RData'

# results_dir <- '~/projects/su2c_v2/results/scRNA/GSCs_Tumour_combined'
# results_file <- 'BTSC_Tumour_combined_id_mixed.RData'
# results_file <- 'diff_exp_pathway_analysis_results.RData'
# rerun_diff_exp <- TRUE

# tryCatch({load(file.path(preproc_dir, data_fname))},
#          error = function(e) {
#            stop('error in loading preprocessed data. try running laura_SU2C_GBM_GSCs_combined_preprocess.R first')
#            })

for (i in 1:length(params)) {
  param.i <- names(params)[i]
  assign(param.i, params[[i]])
}

if (is.character(inp_data)) {
      # we only load data in from file for testing/debugging purposes.
      # inp_data should generally be a Seurat object that is fully preprocessed 
      # as outlined in 'seurat_pipeline' function in helper functions,
      # with PCA calculated
      if (file.exists(inp_data)) {
        inp_data <- readRDS(inp_data)
      } else {
        stop(paste('file', inp_data, 'does not exist'))
      }
}

# setup mapping of dim reduction names to dims to use for each dim reduction
if (dims_use_mapping == 'NULL') {
  # dims_use_mapping should be a named list of lists, with each 'sublist' containing pairs of 
  # dimensions to plot
  dims_use_mapping <- list(pca = list(c(1,2), c(1,3)),
                           tsne = list(c(1,2)))
} else {
  if (!is.list(dims_use_mapping)) {
    stop('dims_use_mapping, if specified, must be a list')
  }
}
if (any(!names(dims_use_mapping) %in% reductions_plot)) {
  offending_reduction <- names(dims_use_mapping)[!names(dims_use_mapping) %in% reductions_plot]
  print(paste('removing', offending_reduction, 'from reductions to be plotted'))
}
if (!all(reductions_plot %in% names(dims_use_mapping))) {
  stop('all reductions plotted must be in names of dim_use_mapping')
}


```

## decide whether or not pca reductions to be used

``` {r}
use_pca <- 'pca' %in% reductions_plot
```

# Explore

``` {r}
# # show variable genes
# VariableFeaturePlot(inp_data, do.plot = TRUE)

# define features to plot
if (feats_plot == 'NULL') {
  # under normal circumstances, should pass a character vector != 'NULL' of features
  # to plot. This is just here to set some default values when running this notebook
  # interactively for testing purposes
  
  # genes_of_interest <- c('NES', 'GFAP', 'OLIG1', 'OLIG2', 'CD44', 'SOX2', 'ALDH1L1',
  #                        'MET', 'STMN1', 'DLL3', 'COL5A1', 'ANXA1', 'VIM', 'SERPINA3',
  #                        'MKI67', 'CDK1', 'PTX3', 'IL6', 'IL6R', 'STAT3', 'JAK1', 'JAK2', 'JAK3')
  genes_of_interest <- c('GFAP', 'SOX2', 'SOX10', 'CD44')
  scores_of_interest <- colnames(inp_data@meta.data)[grep('AUC$', colnames(inp_data@meta.data))]
  score_regex <- paste('RNA.GSC.c[1-2]',
                       'glioma.stem.cell',
                       'Zhong_NPCs_upreg',
                       'nowakowski_(RG-early|IPC-div[1-2])',
                       'cahoy', 
                       'a[1-2].astro',
                       'tirosh',
                       sep = '|')
  scores_of_interest <- scores_of_interest[grep(score_regex, scores_of_interest)]
  numeric_feats <- c('CC.Difference', 'G2M.Score', 'S.Score',
                     genes_of_interest, scores_of_interest,
                     'PC1', 'PC2', 'PC3')
  numeric_feats <- numeric_feats[order(numeric_feats)]
  categorical_feats <- c('SampleType', 'seurat_clusters', 'culture_cond')
  categorical_feats <- categorical_feats[order(categorical_feats)]
  
  feats_plot <- c(categorical_feats, numeric_feats)
}

# set numeric and categorical feats
numeric_feat_inds <- as.logical(lapply(FetchData(inp_data, vars = feats_plot), FUN = is.numeric))
numeric_feats <- feats_plot[numeric_feat_inds]
categorical_feats <- feats_plot[-numeric_feat_inds]

```


***

***

## Distribution of Tumour + Line Cells By Cluster

``` {r}

# calculate proportion of Tumour cells for each cluster
tumour_proportions <- c()
tumour_count <- c()
GSC_count <- c()
all.clust.ids <- unique(inp_data@meta.data$seurat_clusters)
for (clust.id in all.clust.ids) {
  member.ind <- which(inp_data@meta.data$seurat_clusters == clust.id)
  n_tumour <- sum(as.integer(inp_data@meta.data$SampleType[member.ind] == 'Tumour'))
  n_total <- length(member.ind)
  tumour_proportions <- c(tumour_proportions, n_tumour/n_total)
  tumour_count <- c(tumour_count, n_tumour)
  GSC_count <- c(GSC_count, n_total - n_tumour)
}
names(tumour_proportions) <- all.clust.ids
tumour_proportions <- tumour_proportions[order(tumour_proportions)]

inp_data@meta.data$seurat_clusters <- factor(as.character(inp_data@meta.data$seurat_clusters),
                                                     levels = names(tumour_proportions))

# define which cells are in mixed clusters
mixed_clusts <- names(tumour_proportions)[tumour_proportions < 0.90 & tumour_proportions > 0.10]
mixed_clusts
in_mixed_clust <- inp_data@meta.data$seurat_clusters %in% mixed_clusts
names(in_mixed_clust) <- rownames(inp_data@meta.data)
inp_data <- AddMetaData(inp_data, in_mixed_clust, col.name = 'in.mixed.clust')

any_mixed_clust <- any(inp_data@meta.data$in.mixed.clust)
```

### counts/proportions per sample type

``` {r, fig.width=20, fig.height=10}
# show stacked bar charts w/ counts/proportions per sample type
for (show_proportion in c(T,F)) {
   p <- stacked_barcharts(inp_data = inp_data@meta.data, split_by = 'seurat_clusters', color_by = 'SampleType', show_proportion = show_proportion)
   p <- p + theme(axis.text.x = element_text(size = 20),
                  axis.title.x = element_text(size = 20),
                  axis.text.y = element_text(size = 20),
                  axis.title.y = element_text(size = 20),
                  legend.title=element_text(size=40),
                  legend.text=element_text(size=20))
   print(p)
}

# show tumour proportions for each cluster
tumour_proportions
```

### counts/proportions per culture condition

``` {r, fig.width=20, fig.height=10}
# show stacked bar charts with counts/proportions per culture condition
for (show_proportion in c(T,F)) {
   p <- stacked_barcharts(inp_data = inp_data@meta.data, split_by = 'seurat_clusters', color_by = 'culture_cond', show_proportion = show_proportion)
   p <- p + theme(axis.text.x = element_text(size = 20),
                  axis.title.x = element_text(size = 20),
                  axis.text.y = element_text(size = 20),
                  axis.title.y = element_text(size = 20),
                  legend.title=element_text(size=40),
                  legend.text=element_text(size=20))
   print(p)
}
```

### distribution of patient ids by culture condition in mixed cluster cells

``` {r, fig.width=20, fig.height=5, error=TRUE}
# show stacked bar charts with counts/proportions per patient id
if (any_mixed_clust) {
  metadata_subs <-  inp_data@meta.data[inp_data@meta.data$in.mixed.clust == TRUE,]
  set.seed(12345)
  unique_patient_ids <- unique(as.character(metadata_subs$PatientID))
  metadata_subs$PatientID <- factor(metadata_subs$PatientID,
                                    levels = sample(unique_patient_ids,
                                                    size = length(unique_patient_ids),
                                                    replace = FALSE))

  # show actual counts of patient ids per condition
  table(metadata_subs[metadata_subs$culture_cond == 'Adherent', 'PatientID'])
  table(metadata_subs[metadata_subs$culture_cond == 'Sphere', 'PatientID'])
  table(metadata_subs[metadata_subs$culture_cond == 'Tumour', 'PatientID'])

  for (show_proportion in c(T,F)) {
     p <- stacked_barcharts(inp_data = metadata_subs, split_by = 'culture_cond',
                            color_by = 'PatientID', show_proportion = show_proportion)
     p <- p + theme(axis.text.x = element_text(size = 20),
                    axis.title.x = element_text(size = 20),
                    axis.text.y = element_text(size = 20),
                    axis.title.y = element_text(size = 20),
                    legend.title=element_text(size=40),
                    legend.text=element_text(size=20))
     print(p)
  }
}

```


### plots showing mixed cluster status + culture condition

``` {r}

do_dr_plots <- function(filter_by, filter_class, feats_plot, reductions_plot, dims_use_mapping, header_depth = 5) {
  header_string <- paste0(rep('#', header_depth), collapse = '')
  header_string2 <- paste0(rep('#', header_depth + 1), collapse = '')
  for (dr_name in reductions_plot) {
    dr_name_upper <- toupper(dr_name)
    cat(paste(header_string, dr_name_upper, '\n'))
    dims_use_list <- dims_use_mapping[[dr_name]]
    for (i in 1:length(dims_use_list)) {
      dims_i <- dims_use_list[[i]]
      cat(paste(header_string2, paste(dr_name_upper, dims_i[1]), paste(dr_name_upper, dims_i[2]), '\n'))
      make_dr_plots(inp_data, dim1 = dims_i[1], dim2 = dims_i[2], reduction.use = dr_name, 
                    feats_plot = feats_plot, legend_pt_shape = 16, legend_pt_size = 10,
                    filter_by = filter_by, filter_class = filter_class)
      cat('\n')
      cat('\n')
    }
  }
}

```

``` {r, eval=any_mixed_clust, results='asis', error=TRUE}

for (filter_class in c('Tumour', 'Adherent', 'Sphere')) {
  cat(paste('####', filter_class, 'only\n'))
  do_dr_plots(filter_by = 'culture_cond', 
            filter_class = filter_class, 
            feats_plot = c('culture_cond', 'in.mixed.clust'),
            reductions_plot = reductions_plot,
            dims_use_mapping = dims_use_mapping)
  cat('\n\n')
}




cat(paste('#### All Cells\n'))
do_dr_plots(filter_by = 'culture_cond', 
          filter_class = c('Tumour', 'Adherent', 'Sphere'), 
          feats_plot = c('culture_cond', 'in.mixed.clust'),
          reductions_plot = reductions_plot,
          dims_use_mapping = dims_use_mapping)
cat('\n\n')

for (filter_class in c('TRUE', 'FALSE')) {
  cat(paste('####', switch(filter_class, `TRUE` = 'mixed cluster cells', `FALSE` = 'non-mixed cluster cells'), 'only\n'))
  do_dr_plots(filter_by = 'in.mixed.clust', 
            filter_class = filter_class, 
            feats_plot = c('culture_cond', 'in.mixed.clust'),
            reductions_plot = reductions_plot,
            dims_use_mapping = dims_use_mapping)
  cat('\n\n')
}

```

***

## numeric features by cluster

### split by tumour, line, then by whether or not in mixed cluster

``` {r, eval=any_mixed_clust}

for (feat in numeric_feats) {
  p <- sc_jitter_plot(seurat_obj = inp_data, y_axis = feat,
                      size = 0.1, color_by = 'in.mixed.clust', mode = 'boxplot')
  p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1))
  print(p)
}


```


***

### split by tumour, line

``` {r, error=TRUE}
run_wilcox <- function(seurat_obj, feat, class_type, class1, class2) {
  df <- FetchData(seurat_obj, vars = c(feat, class_type))
  x1 <- df[df[,class_type] == class1, feat]
  x2 <- df[df[,class_type] == class2, feat]
  return(wilcox.test(x1, x2, alternative = 'two.sided')$p.value)
}

for (feat in numeric_feats) {
  p <- sc_jitter_plot(seurat_obj = inp_data, y_axis = feat,
                      size = 0.1, color_by = 'SampleType', mode = 'boxplot')
  wilcox_pval <- run_wilcox(seurat_obj = inp_data, feat = feat,
                            class_type = 'SampleType', class1 = 'Tumour', class2 = 'Line')
  p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
    ggtitle(feat, subtitle = paste0('Wilcoxon RS p.value = ', wilcox_pval))
  print(p)
}



# for (feat in numeric_feats) {
#   p <- sc_jitter_plot(seurat_obj = inp_data, y_axis = feat, size = 0.2, mode = 'violin')
#   p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + theme_dark()
#   print(p)
# }

```

***

### split by adherent/sphere/tumour status


``` {r, error=TRUE}
for (feat in numeric_feats) {
  p <- sc_jitter_plot(seurat_obj = inp_data, y_axis = feat,
                      size = 0.1, split_by = 'culture_cond', color_by = 'culture_cond', mode = 'boxplot')
  p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1))
  print(p)
}

```

### split by SampleID

``` {r, error = TRUE}
for (feat in numeric_feats) {
  p <- sc_jitter_plot(seurat_obj = inp_data, y_axis = feat,
                      size = 0.1, split_by = 'SampleID', color_by = 'SampleID', mode = 'boxplot')
  p <- p + theme(legend.position = 'none')
  p <- p + theme(axis.text.x = element_text(angle = 90, hjust = 1))
  print(p)
}
```

### Proportion of culture condition by cluster

``` {r, fig.width=20,fig.height=5, error = TRUE}

# for (feat in numeric_feats[grep('NPC|glioma.stem.cell.|vivo|astroglia|a[1-2].astro', numeric_feats)]) {
#   p <- sc_jitter_plot(seurat_obj = inp_data, y_axis = feat,
#                       size = 0.05, split_by = 'seurat_clusters', color_by = 'culture_cond',
#                       mode = 'boxplot')
#   p <- p + theme(axis.text.x = element_text(size = 20.0),
#                  axis.title.x = element_text(size = 20.0))
#   p <- p + guides(colour = guide_legend(override.aes = list(size=10)))
#   p <- p + theme_linedraw()
#   print(p)
# }

# show proportion of culture conditions per cluster
for (show_proportion in c(T,F)) {
   p <- stacked_barcharts(inp_data = inp_data@meta.data, split_by = 'seurat_clusters', color_by = 'culture_cond', show_proportion = show_proportion)
   p <- p + theme(axis.text.x = element_text(size = 20),
                  axis.title.x = element_text(size = 20),
                  axis.text.y = element_text(size = 20),
                  axis.title.y = element_text(size = 20),
                  legend.title=element_text(size=40),
                  legend.text=element_text(size=20))
   print(p)
}
```

***

## Heatmap of genes + pathways

Only used if PCA embeddings are to be used

``` {r, eval=use_pca, error=TRUE}

PCHeatmap(inp_data, pc.use = 1:10, num.genes = 50)

cor_mat <- cor(FetchData(inp_data, vars = numeric_feats), method = 'spearman')
cor_mat_clust <- hclust(as.dist(1 - cor_mat))
cor_mat <- cor_mat[cor_mat_clust$order, cor_mat_clust$order]
# cor_mat <- cor_mat[,c('PC1', 'PC2', 'PC3')]
corrplot::corrplot(cor_mat, tl.cex = 0.6)

```

***

# Save results
``` {r}
saveRDS(inp_data, file = file.path(results_dir, results_file))
```

# Session Info

``` {r}

Sys.time()
sessionInfo()

```
